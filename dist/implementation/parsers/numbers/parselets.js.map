{"version":3,"sources":["implementation/parsers/numbers/parselets.ts"],"names":[],"mappings":";AACA,wEAAyD;AAEzD;;GAEG;AAEH;IAEI,iBAAiB,CAAC,EAAiB,EAAE,IAAa;QAC9C,IAAI,EAAC,QAAQ,EAAE,KAAK,EAAC,GAAG,EAAE,CAAC;QAC3B,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC1B,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,GAAG,CAAC,CAAC,EAAE,QAAQ,GAAG,MAAM,EAAG,QAAQ,EAAE,EAAE,CAAC;YACpC,IAAI,OAAO,GAAG,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YACzC,EAAE,CAAC,CAAC,CAAC,uBAAK,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChC,KAAK,CAAC;YACV,CAAC;QACL,CAAC;QACD,EAAE,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACvB,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAED;;;;OAIG;IACH,SAAS,CAAC,EAAiB;QACvB,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,IAAI,OAAO,GAAG,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QAC/C,EAAE,CAAC,CAAC,OAAO,KAAK,uBAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAC1B,IAAI,GAAG,CAAC,CAAC,CAAC;YACV,EAAE,CAAC,QAAQ,EAAE,CAAC;QAClB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,KAAK,uBAAK,CAAC,IAAI,CAAC,CAAC,CAAC;YAChC,EAAE,CAAC,QAAQ,EAAE,CAAC;YACd,IAAI,GAAG,CAAC,CAAC;QACb,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;CACJ;AAjCD,wCAiCC;AAEY,QAAA,SAAS,GAAG,IAAI,cAAc,EAAE,CAAC","file":"parselets.js","sourcesContent":["import {FastMath} from \"../../../functions/math\";\r\nimport {Codes} from \"../../../functions/char-indicators\";\r\nimport {ParsingState} from \"../../../abstract/basics/state\";\r\n/**\r\n * Created by User on 29-Nov-16.\r\n */\r\n\r\nexport class _ParseletsType {\r\n\r\n    parseDigitsInBase(ps : ParsingState, base : number) {\r\n        let {position, input} = ps;\r\n        let length = input.length;\r\n        let result = 0;\r\n        for (; position < length ; position++) {\r\n            let curCode = input.charCodeAt(position);\r\n            if (!Codes.isDigit(curCode, base)) {\r\n                break;\r\n            }\r\n        }\r\n        ps.position = position;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Tries to parse a '+' or '-'. Returns the sign that was parsed, or 0 if the parsing failed.\r\n     * @param ps\r\n     * @returns {number}\r\n     */\r\n    parseSign(ps : ParsingState) {\r\n        let sign = 0;\r\n        let curChar = ps.input.charCodeAt(ps.position);\r\n        if (curChar === Codes.minus) {\r\n            sign = -1;\r\n            ps.position++;\r\n        } else if (curChar === Codes.plus) {\r\n            ps.position++;\r\n            sign = 1;\r\n        }\r\n        return sign;\r\n    }\r\n}\r\n\r\nexport const Parselets = new _ParseletsType();"],"sourceRoot":"/src"}