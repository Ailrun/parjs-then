{"version":3,"sources":["implementation/combinators/sequential/sequential.ts"],"names":[],"mappings":";;AAAA,iDAAiD;AACjD,4DAA0D;AAG1D;;GAEG;AACH,YAAoB,SAAQ,oBAAW;IAInC,YAAoB,OAA2B;QAC3C,KAAK,EAAE,CAAC;QADQ,YAAO,GAAP,OAAO,CAAoB;QAH/C,WAAM,GAAG,IAAI,CAAC;QACd,gBAAW,GAAG,KAAK,CAAC;QAIhB,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC;QAChC,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAC1C,CAAC;IACL,CAAC;IACD,MAAM,CAAC,EAAiB;QACpB,IAAI,EAAC,OAAO,EAAC,GAAG,IAAI,CAAC;QACrB,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,IAAI,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACrB,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YACd,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;gBACV,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;YAChC,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC9B,qEAAqE;gBACrE,MAAM,CAAC;YACX,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;gBACnB,EAAE,CAAC,IAAI,GAAG,kBAAS,CAAC,QAAQ,CAAC;gBAC7B,8DAA8D;gBAC9D,2CAA2C;gBAC3C,MAAM,CAAC;YACX,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,+CAA+C;gBAC/C,MAAM,CAAC;YACX,CAAC;QACL,CAAC;QACD,EAAE,CAAC,KAAK,GAAG,OAAO,CAAC;QACnB,EAAE,CAAC,IAAI,GAAG,kBAAS,CAAC,EAAE,CAAC;IAE3B,CAAC;CACJ;AArCD,wBAqCC","file":"sequential.js","sourcesContent":["import {ParjsAction} from \"../../../base/action\";\r\nimport {ReplyKind} from \"../../../abstract/basics/result\";\r\nimport {ParsingState} from \"../../../abstract/basics/state\";\r\nimport {AnyParserAction} from \"../../../abstract/basics/action\";\r\n/**\r\n * Created by User on 21-Nov-16.\r\n */\r\nexport class PrsSeq extends ParjsAction {\r\n    isLoud = true;\r\n    displayName = \"seq\";\r\n    expecting : string;\r\n    constructor(private parsers : AnyParserAction[]) {\r\n        super();\r\n        if (parsers.length === 0) {\r\n            this.expecting = \"anything\";\r\n        } else {\r\n            this.expecting = parsers[0].expecting;\r\n        }\r\n    }\r\n    _apply(ps : ParsingState) : ReplyKind {\r\n        let {parsers} = this;\r\n        let results = [];\r\n        for (let i = 0; i < parsers.length; i++) {\r\n            let cur = parsers[i];\r\n            cur.apply(ps);\r\n            if (ps.isOk) {\r\n                results.maybePush(ps.value);\r\n            } else if (ps.isSoft && i === 0) {\r\n                //if the first parser failed softly then we propagate a soft failure.\r\n                return;\r\n            } else if (ps.isSoft) {\r\n                ps.kind = ReplyKind.HardFail;\r\n                //if a i > 0 parser failed softly, this is a hard fail for us.\r\n                //also, propagate the internal expectation.\r\n                return;\r\n            } else {\r\n                //ps failed hard or fatally. The same severity.\r\n                return;\r\n            }\r\n        }\r\n        ps.value = results;\r\n        ps.kind = ReplyKind.OK;\r\n\r\n    }\r\n}"],"sourceRoot":"/src"}