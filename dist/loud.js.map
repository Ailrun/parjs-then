{"version":3,"sources":["loud.ts"],"names":[],"mappings":"AAAA;;GAEG,CAAC,MAAM","file":"loud.js","sourcesContent":["/**\r\n * @module parjs\r\n */ /** */\r\n\r\nimport {AnyParser} from \"./any\";\r\nimport {ReplyKind, Reply} from \"./reply\";\r\nimport {QuietParser} from \"./quiet\";\r\n\r\nexport interface ParjsProjection<T, TOut> {\r\n    (value : T, state : any) : TOut;\r\n}\r\n\r\nexport type ParjsPredicate<T> = ParjsProjection<T, boolean>;\r\n\r\n\r\n\r\nexport interface LoudParser<T> extends AnyParser {\r\n    /**\r\n     * Applies this parser on the specified input string.\r\n     * @param input The input string.\r\n     * @param initialState An object containing properties that are merged with this parse invocation's parsing state.\r\n     */\r\n    parse(input : string, initialState ?: object) : Reply<T>;\r\n\r\n    //+++ ALTERNATIVE\r\n\r\n    /**\r\n     * P tries to apply this parser. If it fails, then it tries to apply `alt` instead.\r\n     * The return depends on which parser succeeded.\r\n     * @param alt The loud parser alternatie.\r\n     */\r\n    or<S>(alt : LoudParser<S>) : LoudParser<T | S>;\r\n\r\n    or<A, B>(a : LoudParser<A>, b : LoudParser<B>) : LoudParser<T | A | B>;\r\n\r\n    or<A, B, C>(a : LoudParser<A>, b : LoudParser<B>, c : LoudParser<C>) : LoudParser<T | A | B| C>;\r\n\r\n    or<A, B, C, D>(a : LoudParser<A>, b : LoudParser<B>, c : LoudParser<C>, d : LoudParser<D>) : LoudParser<T | A | B| C | D>;\r\n\r\n    soft : LoudParser<T>;\r\n\r\n    /**\r\n     * Applies this parser. If it fails, P succeeds without consuming input and returns the given value.\r\n     * @param val The value alternative.\r\n     */\r\n    orVal<S>(val : S) : LoudParser<T | S>;\r\n\r\n    /**\r\n     * P tries to apply this parser. If it fails, then tries to apply the `parsers` one after the other until one of them succeeds.\r\n     * @param parsers The parsers to try.\r\n     */\r\n    or(...parsers : LoudParser<any>[]) : LoudParser<any>;\r\n\r\n\r\n\r\n    //+ Look Ahead\r\n\r\n    /**\r\n     * P applies this parser. If it succeeds, it backtracks to the original position in the input, effectively succeeding without consuming input.\r\n     */\r\n    readonly backtrack : LoudParser<T>;\r\n\r\n    //+++MAPPING\r\n    /**\r\n     *P Applies this parser, and then applies the given function on the result.\r\n     * @param mapping The function to apply to the result.\r\n     */\r\n    map<S>(mapping : ParjsProjection<T, S>) : LoudParser<S>;\r\n\r\n    /**\r\n     * P applies this parser, and then calls the specified function on the result.\r\n     * Returns the result of P.\r\n     * @param action The action to call.\r\n     */\r\n    act(action : ParjsProjection<T, void>) : LoudParser<T>;\r\n\r\n    /**\r\n     * P returns this parser, statically typed as LoudParser{T}.\r\n     * Only makes sense in TypeScript.\r\n     */\r\n    cast<S>() : LoudParser<S>;\r\n\r\n    mixState(state : any) : LoudParser<T>;\r\n\r\n    //+++ RESTRICTIONS\r\n    /**\r\n     * P applies this parser, and further requires that the result fulfill a condition.\r\n     * If the condition is not fulfilled, the parser fails.\r\n     * @param condition The condition. The 2nd parameter is the user state.\r\n     * @param name The name of the condition the result must satisfy.\r\n     * @param fail The failure type emitted.\r\n     */\r\n    must(condition : ParjsPredicate<T>, name ?: string, fail ?: ReplyKind.Fail) : LoudParser<T>;\r\n\r\n    /**\r\n     * P applies this parser and verifies its result is non-empty.\r\n     * An empty result is any of the following: null, undefined, \"\", [], {}. It is NOT the same as falsy.\r\n     */\r\n        readonly mustBeNonEmpty : LoudParser<T>;\r\n\r\n    /**\r\n     * P applies this parser and requires its result to be identical to {options}.\r\n     * @param options The possible results.\r\n     */\r\n    mustBeOf(...options : T[]) : LoudParser<T>;\r\n\r\n    /**\r\n     * P applies this parser and requires its result not to be identical to any of {options}.\r\n     * @param options The prohibited results.\r\n     */\r\n    mustNotBeOf(...options : T[]) : LoudParser<T>;\r\n\r\n    /**\r\n     * P applies this parser, and requires that it consume at least one character of the input.\r\n     */\r\n    mustCapture(kind ?: ReplyKind.Fail) : LoudParser<T>;\r\n\r\n    /**\r\n     * P sandwiches this parser between two other parsers. Returns the result of this parser.\r\n     * @param preceding The preceding parser.\r\n     * @param proceeding The proceeding parser.\r\n     */\r\n    between(preceding : AnyParser, proceeding : AnyParser) : LoudParser<T>;\r\n\r\n    /**\r\n     * P applies sandwiches this parser between two instances of the same parser. Returns the result of this parser.\r\n     * @param precedingAndPreceding The parser this parser is sandwiched between.\r\n     */\r\n    between(precedingAndPreceding : AnyParser) : LoudParser<T>;\r\n\r\n    //+++SEQUENTIAL\r\n    /**\r\n     * P applies this parser and then immediately another (quiet) parser and returns the result of this parser.\r\n     * @param quiet The quiet parser to follow this one.\r\n     */\r\n    then(quiet : QuietParser) : LoudParser<T>;\r\n\r\n    /**\r\n     * Applies this parser and then immediately another (loud) parser, returning the results of both in a tuple if it succeeds.\r\n     * @param loud The loud parser to follow this one.\r\n     */\r\n    then<S>(loud : LoudParser<S>) : LoudParser<[T, S]>;\r\n\r\n\r\n    /**\r\n     * P applies this parser and then immediately a sequence of parsers, each either quiet or loud returning T.\r\n     * Returns an array containing all the returned values.\r\n     * @param quietOrLoud The series of quiet or loud parsers.\r\n     */\r\n    then(...quietOrLoud : (LoudParser<T> | QuietParser)[]) : LoudParser<T[]>;\r\n\r\n    /**\r\n     * P applies this parser, and them immediately a sequence of quiet parsers.\r\n     * Returns the result of this parser.\r\n     * @param quiet The sequence of quiet parsers.\r\n     */\r\n    then(...quiet : QuietParser[]) : LoudParser<T>;\r\n\r\n    /**\r\n     * An advanced combinator.\r\n     * P applies this parser, and then calls the selector function with this parser's return value to determine the parser to apply next.\r\n     * Because parser construction can be expensive, you can optionally provide a Map object which is used as a cache.\r\n     * @param selector The function that selects which parser to apply next.\r\n     * @param cache An optional cache object.\r\n     */\r\n    thenChoose<TParser extends LoudParser<any>>(selector : (value : T) => TParser, cache ?: Map<T, AnyParser>) : TParser\r\n\r\n    /**\r\n     * P applies this parser exactly {count} times and returns an array of the results.\r\n     * @param count The number of times to apply this parser.\r\n     */\r\n    exactly(count : number) : LoudParser<T[]>;\r\n\r\n    /**\r\n     * Applies this parser repeatedly until it fails, returning the results in an array.\r\n     * @param minSuccess The minimum number of times this parser is applied.\r\n     * @param maxIterations The maximum number of times this parser is applied.\r\n     */\r\n    many(minSuccess ?: number, maxIterations ?: number) : LoudParser<T[]>;\r\n\r\n    /**\r\n     * P applies this parser repeatedly until the `till` parser succeeds, returning an array of all results.\r\n     * P fails if this parser fails before the `till` parser does.\r\n     * @param till The parser\r\n     * @param tillOptional Whether or not the `till` parser is optional. I.e. without this, P will behave similarly to a many\r\n     * parser too, terminating once this parser fails.\r\n     */\r\n    manyTill(till : AnyParser, tillOptional ?: boolean) : LoudParser<T[]>;\r\n\r\n    manyTill(till : ParjsPredicate<T>, tillOptional ?: boolean) : LoudParser<T[]>\r\n\r\n    /**\r\n     * P applies this parser repeatedly, every two occurrences separated by the delimeter parser.\r\n     * P succeeds even when delimeter succeeds but this parser fails. In that case, however, input is not consumed by {delimeter}.\r\n     * @param delimeter The delimeter parser.\r\n     * @param max The maximum number of times this parser is applied.\r\n     */\r\n    manySepBy(delimeter : AnyParser, max ?: number) : LoudParser<T[]>;\r\n}\r\n"],"sourceRoot":"/src"}