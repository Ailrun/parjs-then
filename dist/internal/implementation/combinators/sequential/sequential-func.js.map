{"version":3,"sources":["internal/implementation/combinators/sequential/sequential-func.ts"],"names":[],"mappings":";;AAAA;;GAEG,CAAC,MAAM;AACV,yCAAyC;AAGzC,6CAA4C;AAI5C;;GAEG;AACH,gBAAwB,SAAQ,oBAAW;IAIvC,YAAoB,OAAyB,EACzB,QAAsC,EACtC,KAA4B;QAC5C,KAAK,EAAE,CAAC;QAHQ,YAAO,GAAP,OAAO,CAAkB;QACzB,aAAQ,GAAR,QAAQ,CAA8B;QACtC,UAAK,GAAL,KAAK,CAAuB;QALhD,WAAM,GAAG,IAAI,CAAC;QACd,gBAAW,GAAG,SAAS,CAAC;QAMpB,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IACvC,CAAC;IAED,MAAM,CAAC,EAAiB;QACpB,IAAI,EAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAC,GAAG,IAAI,CAAC;QACtC,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAClB,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;YACX,6CAA6C;YAC7C,MAAM,CAAC;QACX,CAAC;QACD,IAAI,IAAgB,CAAC;QACrB,IAAI,aAAa,GAAG,EAAE,CAAC,KAAK,CAAC;QAC7B,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QACpC,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC;QACnC,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACR,EAAE,CAAC,IAAI,GAAG,iBAAS,CAAC,QAAQ,CAAC;YAC7B,EAAE,CAAC,SAAS,GAAG,oDAAoD,CAAC;YACpE,MAAM,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACR,KAAK,CAAC,GAAG,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACtB,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,EAAE,CAAC,IAAI,GAAG,iBAAS,CAAC,QAAQ,CAAC;QACjC,CAAC;IACL,CAAC;CACJ;AAxCD,gCAwCC","file":"sequential-func.js","sourcesContent":["/**\r\n * @module parjs/internal/implementation/combinators\r\n */ /** */\r\nimport {ParjsAction} from \"../../action\";\r\nimport {Issues} from \"../../common\";\r\nimport {ParsingState} from \"../../state\";\r\nimport {ReplyKind} from \"../../../../reply\";\r\nimport {AnyParserAction} from \"../../../action\";\r\nimport {LoudParser} from \"../../../../loud\";\r\nimport {AnyParser} from \"../../../../any\";\r\n/**\r\n * Created by User on 21-Nov-16.\r\n */\r\nexport class PrsSeqFunc extends ParjsAction {\r\n    isLoud = true;\r\n    displayName = \"seqFunc\";\r\n    expecting : string;\r\n    constructor(private initial : AnyParserAction,\r\n                private selector : (result : any) => AnyParser,\r\n                private cache ?: Map<any, AnyParser>){\r\n        super();\r\n        this.expecting = initial.expecting;\r\n    }\r\n\r\n    _apply(ps : ParsingState) {\r\n        let {initial, selector, cache} = this;\r\n        let results = [];\r\n        initial.apply(ps);\r\n        if (!ps.isOk) {\r\n            //propagate the failure of 'initial' upwards.\r\n            return;\r\n        }\r\n        let next : AnyParser;\r\n        let initialResult = ps.value;\r\n        if (cache) {\r\n            next = cache.get(initialResult);\r\n        }\r\n        if (!next) {\r\n            next = selector(initialResult);\r\n        }\r\n        if (!next) {\r\n            ps.kind = ReplyKind.HardFail;\r\n            ps.expecting = \"failed to determine the right parser for the input\";\r\n            return;\r\n        }\r\n        if (cache) {\r\n            cache.set(initialResult, next);\r\n        }\r\n        next.action.apply(ps);\r\n        if (ps.isSoft) {\r\n            ps.kind = ReplyKind.HardFail;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/src"}