{"version":3,"sources":["internal/implementation/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourcesContent":["/**\r\n * @module parjs/internal/implementation\r\n */ /** */\r\nimport {QUIET_RESULT, FAIL_RESULT} from \"./special-results\";\r\nimport {Issues} from './issues';\r\nimport {ParjsAction, BasicParsingState} from \"./action\";\r\nimport {ReplyKind, Reply} from \"../../reply\";\r\nimport {Trace, FailureReply, SuccessReply, ErrorLocation} from '../reply';\r\nimport _ = require('lodash');\r\nimport {getPositionLocation, infrastructure, visualizeError} from \"../../built.in.parsers/error.location\";\r\nimport {ParsingState} from \"./state\";\r\nimport {StringHelpers} from \"./functions/helpers\";\r\nimport {getError} from \"gulp-typescript/release/utils\";\r\n\r\ninterface ErrorLocationPlus extends ErrorLocation {\r\n    nextLinePosition : number;\r\n}\r\n\r\nfunction getErrorLocation(ps : ParsingState) : ErrorLocationPlus{\r\n    let endln = /\\r\\n|\\n|\\r/g;\r\n    let {input, position} = ps;\r\n    let lastPos = 0;\r\n    let oldPos = -1;\r\n    let result : RegExpMatchArray;\r\n    let line = 0;\r\n\r\n    while (!!(result = endln.exec(ps.input)) && result.index <= position) {\r\n        oldPos = lastPos;\r\n        lastPos = result.index;\r\n        line++;\r\n    }\r\n\r\n    result = endln.exec(ps.input);\r\n\r\n    return {\r\n        row : line,\r\n        column : lastPos - oldPos,\r\n        nextLinePosition : result ? result.index + result[0].length : ps.input.length\r\n    };\r\n}\r\n\r\nfunction getVisualization(text : string, loc : ErrorLocationPlus, reason : string) {\r\n    let line = \" \".repeat(loc.column - 1) + \"^\";\r\n    StringHelpers.splice(text, loc.nextLinePosition, line);\r\n}\r\n\r\nclass ParserState {\r\n\r\n}\r\n\r\n/**\r\n * The base Parjs parser class, which supports only basic parsing operations. Should not be used in user code.\r\n */\r\nexport abstract class BaseParjsParser {\r\n    constructor(public action : ParjsAction) {}\r\n\r\n    get displayName() : string   {\r\n        return this.action.displayName;\r\n    }\r\n\r\n    set displayName(name) {\r\n        this.action.displayName = name;\r\n    }\r\n\r\n    parse(input : string, initialState ?: any) : Reply<any> {\r\n\r\n        if (typeof input !== \"string\") {\r\n            //catches input === undefined, null\r\n            throw new Error(\"input must be a valid string\");\r\n        }\r\n        let {action, isLoud} = this;\r\n        let ps = new BasicParsingState(input);\r\n        ps.state = _.defaults(new ParserState(), initialState);\r\n        action.apply(ps);\r\n\r\n        if (ps.isOk) {\r\n            if (ps.position !== input.length) {\r\n                ps.kind = ReplyKind.SoftFail;\r\n                ps.expecting = \"parsers did not consume all input\";\r\n            }\r\n        }\r\n        if (ps.kind === ReplyKind.Unknown) {\r\n            throw new Error(\"should not happen.\");\r\n        }\r\n        let ret: Reply<any>;\r\n        if (ps.kind === ReplyKind.OK) {\r\n            return Object.assign(new SuccessReply(ps.value === QUIET_RESULT ? undefined : ps.value))\r\n        }\r\n        else {\r\n            let advancedTracing;\r\n            let trace : Trace = {\r\n                state: ps.state,\r\n                position: ps.position,\r\n                expecting: ps.expecting,\r\n                input : input\r\n            } as any;\r\n            if (!(infrastructure in this)) {\r\n                let location = getErrorLocation(ps);\r\n                let visualization = getVisualization(ps.input, location, ps.expecting);\r\n                trace.location = location;\r\n                trace.visualization = visualization;\r\n                trace.stackTrace = ps.stack.join(\" > \");\r\n            }\r\n            return new FailureReply(ps.kind, trace);\r\n        }\r\n    }\r\n\r\n    get isLoud() {\r\n        return this.action.isLoud;\r\n    }\r\n\r\n}"],"sourceRoot":"/src"}