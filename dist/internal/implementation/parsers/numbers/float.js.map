{"version":3,"sources":["internal/implementation/parsers/numbers/float.ts"],"names":[],"mappings":"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","file":"float.js","sourcesContent":["/**\r\n * @module parjs/internal/implementation/parsers\r\n */ /** */\r\nimport {ParjsAction} from \"../../action\";\r\n/**\r\n * Created by User on 28-Nov-16.\r\n */\r\nimport _ = require('lodash');\r\nimport {Codes} from \"../../functions/char-indicators\";\r\nimport decimalPoint = Codes.decimalPoint;\r\nimport {FastMath} from \"../../functions/math\";\r\nimport NegativeExponents = FastMath.NegativeExponents;\r\nimport {Parselets} from \"./parselets\";\r\nimport {ReplyKind} from \"../../../../reply\";\r\nimport {ParsingState} from \"../../state\";\r\n\r\nexport interface FloatOptions {\r\n    allowSign ?: boolean;\r\n    allowImplicitZero ?: boolean;\r\n    allowFloatingPoint ?: boolean;\r\n    allowExponent ?: boolean;\r\n}\r\n\r\nconst defaultFloatOptions : FloatOptions = {\r\n    allowExponent : true,\r\n    allowSign : true,\r\n    allowImplicitZero : true,\r\n    allowFloatingPoint : true\r\n};\r\n\r\nconst msgOneOrMoreDigits = \"one or more digits\";\r\nconst msgExponentSign = \"exponent sign (+ or -)\";\r\nexport class PrsFloat extends ParjsAction {\r\n    expecting = \"a floating-point number\";\r\n    displayName = \"float\";\r\n    isLoud = true;\r\n    constructor(private options : FloatOptions) {\r\n        super();\r\n        this.options = _.defaults(options, defaultFloatOptions);\r\n    }\r\n\r\n    _apply(ps : ParsingState) {\r\n        /*\r\n            This work is really better done using Parjs itself, but it's wrapped in (mostly) a single parser for efficiency purposes.\r\n\r\n            We want a configurable number parser that can parse floating point numbers in any base, with or without a sign, and with or without\r\n            an exponent...\r\n\r\n            Here are the rules of this parser.\r\n\r\n            Replace {1,2 3, 4} by the digits allowed with the base, which is configurable.\r\n\r\n            BASIC NUMBER FORMS - parser must be one of:\r\n                a. 1234 : integer\r\n                b. 12.3 : floating point, allowed if {allowFloatingPoint}.\r\n                c. .123 : floating point, implicit whole part. Requires {allowFloatingPoint && allowImplicitZero}\r\n                d. 123. : floating point, implicit fractional part. Requires {allowFloatingPoint && allowImplicitZero}\r\n\r\n            CONFIGURABLE EXTRAS:\r\n                a. Sign prefix: (+|-) preceeding the number. Allowed if {allowSign}.\r\n                b. Exponent suffix: (e|E)(+|-)\\d+. Allowed if {allowExponent}. Can be combined with {!allowFloatingPoint}.\r\n\r\n            FAILURES:\r\n                a. '' - no characters consumed. Parser fails.\r\n                b. '.' - could be understood as an implicit 0.0, but will not be parsed by this parser.\r\n                c. '1e+' -\r\n                    with {allowExponent}, this fails after consuming '1e+' because it expected an integer after the + but didn't find one.\r\n                    without that flag, this succeeds and parses just 1.\r\n\r\n            SUCCESSES:\r\n                a. '1abc' - The parser will just consume and return 1.\r\n                b. '10e+1' - {allowExponent} can be true even if {allowFloatingPoint} isn't.\r\n\r\n            ISSUES:\r\n                a. If base >= 15 then the character 'e' is a digit and so {allowExponent} must be false since it cannot be parsed.\r\n                   Otherwise, an error is thrown.\r\n                b.\r\n         */\r\n        let {options : {allowSign, allowFloatingPoint, allowImplicitZero, allowExponent}} = this;\r\n        let {position, input} = ps;\r\n        if (position >= input.length) {\r\n            ps.kind = ReplyKind.SoftFail;\r\n            return;\r\n        }\r\n        let initPos = position;\r\n        let Sign = 1;\r\n        let hasSign = false, hasWhole = false, hasFraction = false;\r\n        if (allowSign) {\r\n            //try parse a sign\r\n            Sign = Parselets.parseSign(ps);\r\n            if (Sign === 0) {\r\n                Sign = 1;\r\n            } else {\r\n                hasSign = true;\r\n            }\r\n        }\r\n        //after a sign there needs to come an integer part (if any).\r\n        let prevPos = ps.position;\r\n        Parselets.parseDigitsInBase(ps, 10);\r\n        hasWhole = ps.position !== prevPos;\r\n        //now if allowFloatingPoint, we try to parse a decimal point.\r\n        let nextChar = input.charCodeAt(ps.position);\r\n        prevPos = ps.position;\r\n        if (!allowImplicitZero && !hasWhole) {\r\n            //fail because we don't allow \".1\", and similar without allowImplicitZero.\r\n            ps.kind = hasSign ? ReplyKind.HardFail : ReplyKind.SoftFail;\r\n            ps.expecting = msgOneOrMoreDigits;\r\n            return;\r\n        }\r\n        floatingParse: {\r\n            if (allowFloatingPoint && nextChar === Codes.decimalPoint) {\r\n                //skip to the char after the decimal point\r\n                ps.position++;\r\n                let prevFractionalPos = ps.position;\r\n                //parse the fractional part\r\n                Parselets.parseDigitsInBase(ps, 10);\r\n                hasFraction = prevFractionalPos !== ps.position;\r\n                if (!allowImplicitZero && !hasFraction) {\r\n                    //we encountered something like 212. but allowImplicitZero is false.\r\n                    //that means we need to backtrack to the . character and succeed in parsing the integer.\r\n                    //the remainder is not a valid number.\r\n                    break floatingParse;\r\n                }\r\n\r\n                //after parseDigits has been invoked, the ps.position is on the next character (which could be e).\r\n                nextChar = input.charCodeAt(ps.position);\r\n                prevPos = ps.position;\r\n            }\r\n\r\n            if (!hasWhole && !hasFraction) {\r\n                //even if allowImplicitZero is true, we still don't parse '.' as '0.0'.\r\n                ps.kind = hasSign ? ReplyKind.HardFail : ReplyKind.SoftFail;\r\n                ps.expecting = msgOneOrMoreDigits;\r\n                return;\r\n            }\r\n            //note that if we don't allow floating point, the char that might've been '.' will instead be 'e' or 'E'.\r\n            //if we do allow floating point, then the previous block would've consumed some characters.\r\n            if (allowExponent && (nextChar === Codes.e || nextChar === Codes.E)) {\r\n                ps.position++;\r\n                let expSign = Parselets.parseSign(ps);\r\n                if (expSign === 0) {\r\n                    ps.kind = ReplyKind.HardFail;\r\n                    ps.expecting = msgExponentSign;\r\n                    return;\r\n                }\r\n                let prevFractionalPos = ps.position;\r\n                Parselets.parseDigitsInBase(ps, 10);\r\n                if (ps.position === prevFractionalPos) {\r\n                    //we parsed e+ but we did not parse any digits.\r\n                    ps.kind = ReplyKind.HardFail;\r\n                    ps.expecting = msgOneOrMoreDigits;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        ps.kind = ReplyKind.OK;\r\n        ps.value = parseFloat(input.substring(initPos, ps.position));\r\n    }\r\n}"],"sourceRoot":"/src"}