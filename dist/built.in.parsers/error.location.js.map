{"version":3,"sources":["built.in.parsers/error.location.ts"],"names":[],"mappings":"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","file":"error.location.js","sourcesContent":["/**\r\n * Created by lifeg on 4/21/2017.\r\n */\r\nimport {Parjs} from \"../\";\r\nimport _ = require('lodash');\r\nimport {LoudParser} from \"../loud\";\r\nimport {StringHelpers} from \"../internal/implementation/functions/helpers\";\r\nimport {Trace} from \"../internal/reply\";\r\nexport interface ErrorLocation {\r\n    rowIndex : number;\r\n    colPrefix : string;\r\n}\r\nexport const infrastructure = Symbol(\"infrastructure\");\r\nlet parseUntilPositionReached : LoudParser<ErrorLocation>;\r\nfunction buildParser() {\r\n    if (parseUntilPositionReached) return;\r\n    let protoState = {\r\n        rowIndex : 0,\r\n        colPrefix : \"\"\r\n    } as ErrorLocation;\r\n\r\n    let parseLinebreak = Parjs.newline.act((nl, st) => {\r\n        st.colPrefix = \"\";\r\n        st.rowIndex++;\r\n        st.realPosition += nl.length;\r\n    }).q;\r\n\r\n    let parseOtherChar = Parjs.anyChar.act((c, st) => {\r\n        st.colPrefix += c;\r\n        st.realPosition += c.length;\r\n    }).q;\r\n\r\n    parseUntilPositionReached = Parjs.eof.q.or(parseLinebreak.or(parseOtherChar).manyTill(state => {\r\n        return state.seekPosition - 1 >= state.realPosition;\r\n    }).then(Parjs.rest.q)).state.map(s => _.pickBy(s, (v, x) => x in protoState) as ErrorLocation).mixState(protoState);\r\n    parseUntilPositionReached[infrastructure] = true;\r\n}\r\n\r\nexport function getPositionLocation(text : string, position : number) {\r\n    buildParser();\r\n    return parseUntilPositionReached.parse(text, {\r\n        seekPosition : position\r\n    }).resolve();\r\n}\r\n\r\nexport function visualizeError(input : string, position : number, location : ErrorLocation) {\r\n    let endline = /(\\r\\n|\\n|\\r)/g;\r\n    let split = input.split(endline, location.rowIndex);\r\n    let errorLine = location.colPrefix.split(\"\").map(c => c === \"\\t\" ? \"    \" : \" \").join(\"\") + \"^\";\r\n    split.splice(location.rowIndex + 1)\r\n    let endlIndex = input.length;\r\n    endline.lastIndex = Math.max(0, position- 1);\r\n    let r = endline.exec(input);\r\n    if (r) {\r\n        endlIndex = endline.lastIndex + r[0].length;\r\n    }\r\n\r\n    return StringHelpers.splice(input, endlIndex, errorLine)\r\n}\r\n\r\n"],"sourceRoot":"/src"}