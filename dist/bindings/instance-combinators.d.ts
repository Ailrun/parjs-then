import { BaseParjsParser } from "../base/parser";
import { LoudParser } from "../abstract/combinators/loud";
import { FailResultKind } from "../abstract/basics/result";
import { QuietParser } from "../abstract/combinators/quiet";
import { AnyParser } from "../abstract/combinators/any";
export declare class ParjsParser extends BaseParjsParser implements LoudParser<any>, QuietParser {
    thenChoose<TParser extends AnyParser>(selector: (x: any) => TParser, map?: Map<any, TParser>): TParser;
    between(preceding: AnyParser, proceeding?: AnyParser): any;
    readonly backtrack: ParjsParser;
    mustCapture(failType?: FailResultKind): ParjsParser;
    or(...others: AnyParser[]): any;
    readonly state: LoudParser<any>;
    map(f: any): ParjsParser;
    act(f: any): ParjsParser;
    readonly q: ParjsParser;
    readonly soft: ParjsParser;
    then(...next: any[]): any;
    many(minSuccesses?: number, maxIters?: number): ParjsParser;
    manyTill(till: AnyParser, tillOptional?: boolean): ParjsParser;
    manySepBy(sep: AnyParser, maxIterations?: number): ParjsParser;
    exactly(count: number): ParjsParser;
    result(r: any): ParjsParser;
    readonly not: ParjsParser;
    orVal(x: any): ParjsParser;
    cast(): this;
    readonly str: ParjsParser;
    must(condition: (result: any, state: any) => boolean, name?: string, fail?: FailResultKind): ParjsParser;
    mustNotBeOf(...options: any[]): ParjsParser;
    mustBeOf(...options: any[]): ParjsParser;
    readonly mustBeNonEmpty: ParjsParser;
    withName(newName: string): this;
}
