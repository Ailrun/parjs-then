{"version":3,"sources":["bindings/instance-combinators.ts"],"names":[],"mappings":"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","file":"instance-combinators.js","sourcesContent":["/**\r\n * Created by User on 22-Nov-16.\r\n */\r\nimport {\r\n    PrsSeq\r\n    , MapParser, PrsStr, PrsNot, PrsQuiet, PrsMapResult, PrsAlts, PrsBacktrack, PrsMust, PrsMustCapture, PrsMany, PrsSeqFunc, PrsExactly, PrsManyTill, PrsManySepBy, PrsAltVal} from '../implementation/combinators';\r\nimport {BaseParjsParser} from \"../base/parser\";\r\nimport _ = require('lodash');\r\nimport {ParjsAction} from \"../base/action\";\r\nimport {Predicates} from \"../functions/predicates\";\r\nimport {LoudParser} from \"../abstract/combinators/loud\";\r\nimport {ResultKind, FailResult, FailResultKind} from \"../abstract/basics/result\";\r\nimport {QuietParser} from \"../abstract/combinators/quiet\";\r\nimport {AnyParser} from \"../abstract/combinators/any\";\r\nimport {PrsSoft} from \"../implementation/combinators/alternatives/soft\";\r\nimport {ActParser} from \"../implementation/combinators/map/act\";\r\n\r\nfunction wrap(action : ParjsAction) {\r\n    return new ParjsParser(action);\r\n}\r\n\r\nexport class ParjsParser extends BaseParjsParser implements LoudParser<any>, QuietParser{\r\n\r\n    thenChoose<TParser extends AnyParser>(selector : (x : any) => TParser, map ?: Map<any, TParser>) : TParser {\r\n        return wrap(new PrsSeqFunc(this.action, selector, map)).withName(\"thenChoose\") as any;\r\n    }\r\n\r\n    between(preceding : AnyParser, proceeding ?: AnyParser) {\r\n        let bet : any;\r\n        if (proceeding) {\r\n            bet = preceding.q.then(this).then(proceeding.q);\r\n        } else {\r\n            bet = preceding.q.then(this).then(preceding.q);\r\n        }\r\n        return bet.withName(\"between\");\r\n    }\r\n    get backtrack() {\r\n        return wrap(new PrsBacktrack(this.action)).withName(\"backtrack\");\r\n    }\r\n\r\n    mustCapture(failType : FailResultKind = ResultKind.HardFail) {\r\n        return wrap(new PrsMustCapture(this.action, failType)).withName(\"mustCapture\");\r\n    }\r\n\r\n    or(...others : AnyParser[]) {\r\n        return wrap(new PrsAlts([this, ...others].map(x => x.action))).withName(\"or\");\r\n    }\r\n\r\n    get state(): LoudParser<any> {\r\n        let ret = wrap(new MapParser(this.action, (r, s) => s));\r\n        return ret.withName(\"state\");\r\n    }\r\n\r\n    map(f) {\r\n        //f is (result, state) => any if this.isLoud\r\n        //f is (state) => any otherwise\r\n        let mapper : (result : any, state : any) => any;\r\n        if (this.isLoud) {\r\n            mapper = f;\r\n        } else {\r\n            mapper = (result, state) => f(state);\r\n        }\r\n        return wrap(new MapParser(this.action, mapper)).withName(\"map\");\r\n    }\r\n\r\n    act(f) {\r\n        //f is (result, state) => void if this.isLoud\r\n        //f is (state) => void otherwise.\r\n        let mapper : (result : any, state : any) => void;\r\n        if (this.isLoud) {\r\n            mapper = f;\r\n        } else {\r\n            mapper = (result, state) => f(state);\r\n        }\r\n        return wrap(new ActParser(this.action, mapper)).withName(\"act\");\r\n    }\r\n\r\n    get q() {\r\n        return wrap(new PrsQuiet(this.action)).withName(\"quiet\");\r\n    }\r\n\r\n    get soft() {\r\n        return wrap(new PrsSoft(this.action)).withName(\"soften\");\r\n    }\r\n\r\n    then(...next : any[]) : any {\r\n        let actions = [this.action, ...next.map(x => x.action)];\r\n        let seqParse = wrap(new PrsSeq(actions));\r\n        let loudCount = actions.filter(x => x.isLoud).length;\r\n        let ret;\r\n        if (loudCount === 1) {\r\n            ret = seqParse.map(x => x[0]);\r\n        } else if (loudCount === 0) {\r\n            ret= seqParse.q;\r\n        } else {\r\n            ret= seqParse;\r\n        }\r\n        return ret.withName(\"then\");\r\n    }\r\n    many(minSuccesses : number = 0, maxIters : number = Infinity) {\r\n        return wrap(new PrsMany(this.action, maxIters, minSuccesses)).withName(\"many\");\r\n    }\r\n\r\n    manyTill(till : AnyParser, tillOptional = false) {\r\n        return wrap(new PrsManyTill(this.action, till.action, tillOptional)).withName(\"manyTill\");\r\n    }\r\n\r\n    manySepBy(sep : AnyParser, maxIterations = Infinity) {\r\n        return wrap(new PrsManySepBy(this.action, sep.action, maxIterations)).withName(\"manySepBy\");\r\n    }\r\n\r\n    exactly(count : number) {\r\n        return wrap(new PrsExactly(this.action, count)).withName(\"exactly\");\r\n    }\r\n\r\n\r\n    result(r : any) {\r\n        return wrap(new PrsMapResult(this.action, r)).withName(\"result\");\r\n    }\r\n\r\n    get not() {\r\n        return wrap(new PrsNot(this.action)).withName(\"not\");\r\n    }\r\n\r\n    orVal(x : any) {\r\n        return wrap(new PrsAltVal(this.action, x)).withName(\"orVal\");\r\n    }\r\n\r\n    cast() {\r\n        return this;\r\n    }\r\n\r\n    get str() {\r\n        return wrap(new PrsStr(this.action)).withName(\"str\");\r\n    }\r\n\r\n    must(condition : (result : any, state : any) => boolean, name = \"(unnamed condition)\", fail : FailResultKind = ResultKind.HardFail) {\r\n        return wrap(new PrsMust(this.action, condition, fail, name)).withName(\"must\");\r\n    }\r\n\r\n    mustNotBeOf(...options : any[]) {\r\n        return this.must(x => !options.includes(x), `none of: ${options.join(\", \")}`).withName(\"mustNotBeOf\");\r\n    }\r\n\r\n    mustBeOf(...options : any[]) {\r\n        return this.must(x => options.includes(x), `one of: ${options.join(\", \")}`).withName(\"mustBeOf\");\r\n    }\r\n\r\n    get mustBeNonEmpty() {\r\n        return this.must(x => {\r\n            return Predicates.nonEmpty(x);\r\n        }, `be non-empty`, ResultKind.HardFail).withName(\"mustBeNonEmpty\");\r\n    }\r\n\r\n    withName(newName : string) {\r\n        (this as {displayName : string}).displayName = newName;\r\n        return this;\r\n    }\r\n\r\n}"],"sourceRoot":"/src"}